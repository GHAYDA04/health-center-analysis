# -*- coding: utf-8 -*-
"""analyze_health_feedback.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i07JOrkIjtkOnuk-KupWdrP-kRVFF_8z
"""

import streamlit as st
import pandas as pd
import numpy as np
import os

# Define a secure password (replace with a strong password in production)
SECURE_PASSWORD = "HealthCenter2025"  # Replace with a strong password in production

# Mapping for ratings
RATING_MAP = {
    'Excellent': 5,
    'Very Good': 4,
    'Good': 3,
    'Acceptable': 2,
    'Poor': 1
}

# Yes/No mapping for percentages
YES_MAP = {
    'Yes': 'yes',
    'To Some Extent': 'to_some_extent',
    'No': 'no'
}

# Define sections with their column names (exact or partial for matching)
SECTIONS = {
    'General Medical': [
        'Ease of access and booking with doctors',
        'Clarity of diagnosis and explanation to the patient',
        'Level of care and follow-up'
    ],
    'Dental': [
        'Ease of booking dental appointments',
        'Quality of service provided',
        'Cleanliness and equipment of the dental clinic'
    ],
    'Pediatrics': [
        'Staff interaction with mothers and children',
        'Availability of necessary child check-ups',
        'Provision of health guidance for mother and child'
    ],
    'Pharmacy': [
        'Speed of medication dispensing',
        'Availability of required medications',
        'Clarity of instructions when dispensing medication'
    ],
    'Family Clinic': [
        'Quality of services provided in the family clinic',
        'Attention to providing health consultations'
    ],
    'Lab': [
        'Ease of conducting lab tests',
        'Speed of receiving results',
        'Accuracy of lab results'
    ],
    'Emergency': [
        'Speed of response in the emergency department',
        'Efficiency of medical staff in handling emergency cases',
        'Availability of necessary equipment for emergency cases'
    ],
    'Registration': [
        'Ease of registration procedures',
        'Speed of transaction processing'
    ],
    'Waiting Area': [
        'Availability of sufficient seating',
        'Cleanliness of the waiting area',
        'Waiting time before entering the clinic'
    ],
    'Cleanliness': [
        'Overall cleanliness of the center',
        'Availability of clean and functional restrooms'
    ]
}

# Other key columns
OVERALL_EXPERIENCE_COL = 'Overall, how would you rate your experience at the health center?'
RECOMMEND_COL = 'Would you recommend others to visit this health center?'
ALL_SERVICES_COL = 'Do you believe the center provides all the health services you need?'
HOURS_SUITABLE_COL = 'Are the center\'s operating hours suitable for you?'
POSITIVES_COL = 'What are the most notable positives you found at the health center?'
SUGGESTIONS_COL = 'What are your suggestions for improving and developing the health center\'s services?'

def analyze_csv(file_path):
    try:
        # Read CSV
        df = pd.read_csv(file_path, encoding='utf-8')
    except FileNotFoundError:
        st.error(f"Error: The file '{file_path}' does not exist. Please upload a valid CSV file.")
        return None
    except Exception as e:
        st.error(f"Error while reading the file: {e}")
        return None

    # Strip any leading/trailing spaces in column names
    df.columns = df.columns.str.strip()

    # Identify all rating columns (those with values in RATING_MAP)
    rating_cols = [col for col in df.columns if df[col].dropna().isin(RATING_MAP.keys()).any()]

    # Filter out responses where all ratings are the same (e.g., all 'Excellent', 'Poor', etc.)
    filtered_df = df.copy()
    if rating_cols:
        # Convert ratings to numeric for filtering
        temp_df = df[rating_cols].applymap(lambda x: RATING_MAP.get(x, np.nan))
        # Check if all ratings in a row are the same by computing the standard deviation
        row_std = temp_df.std(axis=1, skipna=True)
        # Keep rows where standard deviation is not 0 (i.e., ratings are not all identical)
        filtered_df = df[row_std != 0].reset_index(drop=True)

    # If no rows remain after filtering, display a warning
    if filtered_df.empty:
        st.warning("No responses remain after filtering out uniform ratings (e.g., all 'Excellent' or 'Poor').")
        return None

    # Map ratings to numbers for the filtered DataFrame
    numeric_df = filtered_df[rating_cols].applymap(lambda x: RATING_MAP.get(x, np.nan))

    # Centralized Evaluation Score: average of all ratings across all responses
    all_ratings = numeric_df.values.flatten()
    all_ratings = all_ratings[~np.isnan(all_ratings)]
    centralized_score = np.mean(all_ratings) if len(all_ratings) > 0 else 0

    # Overall Experience Score
    if OVERALL_EXPERIENCE_COL in numeric_df.columns:
        overall_scores = numeric_df[OVERALL_EXPERIENCE_COL].dropna()
        overall_score = np.mean(overall_scores) if not overall_scores.empty else 0
    else:
        overall_score = 0

    # Section scores
    section_scores = {}
    for section, cols in SECTIONS.items():
        matched_cols = [col for col in numeric_df.columns if any(c.strip() in col for c in cols)]
        if matched_cols:
            section_data = numeric_df[matched_cols].values.flatten()
            section_data = section_data[~np.isnan(section_data)]
            section_scores[section] = np.mean(section_data) if len(section_data) > 0 else 0

    # Other metrics
    if RECOMMEND_COL in filtered_df.columns:
        recommend_counts = filtered_df[RECOMMEND_COL].value_counts(normalize=True) * 100
        recommend_yes = recommend_counts.get('Yes', 0)
        recommend_no = recommend_counts.get('No', 0)
        recommend_some = recommend_counts.get('To Some Extent', 0)
    else:
        recommend_yes = 0
        recommend_no = 0
        recommend_some = 0

    if ALL_SERVICES_COL in filtered_df.columns:
        services_counts = filtered_df[ALL_SERVICES_COL].value_counts(normalize=True) * 100
        services_yes = services_counts.get('Yes', 0)
        services_some = services_counts.get('To Some Extent', 0)
        services_no = services_counts.get('No', 0)
    else:
        services_yes = 0
        services_some = 0
        services_no = 0

    if HOURS_SUITABLE_COL in filtered_df.columns:
        hours_counts = filtered_df[HOURS_SUITABLE_COL].value_counts(normalize=True) * 100
        hours_yes = hours_counts.get('Yes', 0)
        hours_no = hours_counts.get('No', 0)
        hours_some = hours_counts.get('To Some Extent', 0)
    else:
        hours_yes = 0
        hours_no = 0
        hours_some = 0

    # Open text
    positives = filtered_df[POSITIVES_COL].dropna().unique().tolist() if POSITIVES_COL in filtered_df.columns else []
    suggestions = filtered_df[SUGGESTIONS_COL].dropna().unique().tolist() if SUGGESTIONS_COL in filtered_df.columns else []

    return {
        'centralized_score': centralized_score,
        'overall_score': overall_score,
        'section_scores': section_scores,
        'recommend_yes': recommend_yes,
        'recommend_no': recommend_no,
        'recommend_some': recommend_some,
        'services_yes': services_yes,
        'services_some': services_some,
        'services_no': services_no,
        'hours_yes': hours_yes,
        'hours_no': hours_no,
        'hours_some': hours_some,
        'positives': positives,
        'suggestions': suggestions
    }

# Streamlit UI with security
st.title("Health Center Survey Analysis")

# Password protection using session state
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False

if not st.session_state.authenticated:
    st.subheader("Login")
    password = st.text_input("Enter Password", type="password")
    if st.button("Login"):
        if password == SECURE_PASSWORD:
            st.session_state.authenticated = True
            st.success("Login successful!")
        else:
            st.error("Incorrect password")
    st.stop()

# Main application
st.write("Upload a CSV file to analyze the health center ratings.")
st.warning("Warning: Ensure the CSV file does not contain sensitive personal information (e.g., names or ID numbers) to protect respondent privacy.")

# File uploader
uploaded_file = st.file_uploader("Choose a CSV file", type="csv")

if uploaded_file is not None:
    # Save the uploaded file temporarily
    temp_file_path = "temp_feedback.csv"
    with open(temp_file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())

    # Analyze the file
    results = analyze_csv(temp_file_path)

    # Immediately delete the temporary file to ensure data privacy
    if os.path.exists(temp_file_path):
        os.remove(temp_file_path)

    # Display results
    if results is not None:
        st.header("Analysis Results")

        # Centralized and Overall Scores
        st.subheader("General Ratings")
        st.write(f"- **Centralized Score** (average of all ratings across responses): {results['centralized_score']:.2f} out of 5")
        st.write(f"- **Overall Experience Score** (average of overall experience field only): {results['overall_score']:.2f} out of 5")

        # Section Scores
        st.subheader("Ratings by Section")
        st.table({
            "Section": list(results['section_scores'].keys()),
            "Rating (out of 5)": [f"{score:.2f}" for score in results['section_scores'].values()]
        })

        # Other Metrics
        st.subheader("Other Metrics")
        st.write(f"- **Recommendation Rate**: {results['recommend_yes']:.0f}% 'Yes', {results['recommend_some']:.0f}% 'To Some Extent', {results['recommend_no']:.0f}% 'No'")
        st.write(f"- **All Services Availability**: {results['services_yes']:.0f}% 'Yes', {results['services_some']:.0f}% 'To Some Extent', {results['services_no']:.0f}% 'No'")
        st.write(f"- **Operating Hours Suitability**: {results['hours_yes']:.0f}% 'Yes', {results['hours_some']:.0f}% 'To Some Extent', {results['hours_no']:.0f}% 'No'")

        # Open Text Responses
        st.subheader("Open Text Responses")
        st.write("**Notable Positives**:")
        for p in results['positives']:
            st.write(f"- {p}")
        st.write("**Improvement Suggestions**:")
        for s in results['suggestions']:
            st.write(f"- {s}")

