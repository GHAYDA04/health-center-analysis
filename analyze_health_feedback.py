# -*- coding: utf-8 -*-
"""analyze_health_feedback.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i07JOrkIjtkOnuk-KupWdrP-kRVFF_8z
"""

import streamlit as st
import pandas as pd
import numpy as np
import os
import pdfplumber

# Retrieve password from environment variable (set it in your environment or Streamlit Secrets)
SECURE_PASSWORD = os.getenv("APP_PASSWORD")

# Mapping for ratings
RATING_MAP = {
    'ممتاز': 5,
    'جيد جدا': 4,
    'جيد': 3,
    'مقبول': 2,
    'ضعيف': 1
}

# Yes/No mapping for percentages
YES_MAP = {
    'نعم': 'yes',
    'إلى حد ما': 'to_some_extent',
    'لا': 'no'
}

# Define sections with their column names (exact or partial for matching)
SECTIONS = {
    'General Medical': [
        'مدى سهولة الوصول والحجز لدى الأطباء',
        'وضوح التشخيص والشرح للمريض',
        'مستوى الاهتمام والمتابعة'
    ],
    'Dental': [
        'سهولة الحجز لمواعيد الأسنان',
        'جودة الخدمة المقدمة',
        'نظافة وتجهيزات عيادة الأسنان'
    ],
    'Pediatrics & maternity': [
        'تعامل الكادر الطبي مع الأمهات والأطفال',
        'توفّر الفحوصات اللازمة للأطفال',
        'توفير إرشادات صحية للأم والطفل'
    ],
    'Pharmacy': [
        'سرعة صرف الأدوية',
        'توافر الأدوية المطلوبة',
        'وضوح التعليمات عند صرف الدواء'
    ],
    'Family Clinic': [
        'جودة الخدمات المقدمة في عيادة الأسرة',
        'الاهتمام بتقديم الاستشارات الصحية'
    ],
    'Lab': [
        'سهولة إجراء الفحوصات المخبرية',
        'سرعة استلام النتائج',
        'دقة النتائج المخبرية'
    ],
    'Emergency': [
        'سرعة الاستجابة في قسم الطوارئ',
        'كفاءة الكادر الطبي في التعامل مع الحالات الطارئة',
        'توفر التجهيزات والمعدات اللازمة للحالات الطارئة'
    ],
    'Registration': [
        'سهولة إجراءات التسجيل',
        'سرعة إنجاز المعاملات'
    ],
    'Waiting Area': [
        'توفر أماكن جلوس كافية',
        'نظافة قاعة الانتظار',
        'مدة الانتظار قبل الدخول إلى العيادة'
    ],
    'Cleanliness': [
        'نظافة المركز بشكل عام',
        'توفر دورات مياه نظيفة وصالحة للاستخدام'
    ]
}

# Other key columns
OVERALL_EXPERIENCE_COL = 'بشكل عام، كيف تقيم تجربتك في المركز الصحي؟'
RECOMMEND_COL = 'هل توصي الآخرين بمراجعة هذا المركز الصحي؟'
ALL_SERVICES_COL = 'هل تعتقد أن المركز يوفر جميع الخدمات الصحية التي تحتاجها'
HOURS_SUITABLE_COL = 'هل ساعات عمل المركز مناسبة لك'
POSITIVES_COL = 'ما أبرز الإيجابيات التي وجدتها في المركز الصحي؟'
SUGGESTIONS_COL = 'ما هي اقتراحاتك لتطوير وتحسين خدمات المركز الصحي؟'

def analyze_data(df):
    # Strip any leading/trailing spaces in column names
    df.columns = df.columns.str.strip()

    # Identify all rating columns (those with values in RATING_MAP)
    rating_cols = [col for col in df.columns if df[col].dropna().isin(RATING_MAP.keys()).any()]

    # Filter out responses where all ratings are the same (e.g., all 'ممتاز', 'ضعيف', etc.)
    filtered_df = df.copy()
    if rating_cols:
        # Convert ratings to numeric for filtering
        temp_df = df[rating_cols].applymap(lambda x: RATING_MAP.get(x, np.nan))
        # Check if all ratings in a row are the same by computing the standard deviation
        row_std = temp_df.std(axis=1, skipna=True)
        # Keep rows where standard deviation is not 0 (i.e., ratings are not all identical)
        filtered_df = df[row_std != 0].reset_index(drop=True)

    # If no rows remain after filtering, display a warning
    if filtered_df.empty:
        st.warning("No responses remain after filtering out uniform ratings (e.g., all 'ممتاز' or 'ضعيف').")
        return None

    # Map ratings to numbers for the filtered DataFrame
    numeric_df = filtered_df[rating_cols].applymap(lambda x: RATING_MAP.get(x, np.nan))

    # Centralized Evaluation Score: average of all ratings across all responses
    all_ratings = numeric_df.values.flatten()
    all_ratings = all_ratings[~np.isnan(all_ratings)]
    centralized_score = np.mean(all_ratings) if len(all_ratings) > 0 else 0
    centralized_score_percent = (centralized_score / 5) * 100

    # Overall Experience Score
    if OVERALL_EXPERIENCE_COL in numeric_df.columns:
        overall_scores = numeric_df[OVERALL_EXPERIENCE_COL].dropna()
        overall_score = np.mean(overall_scores) if not overall_scores.empty else 0
        overall_score_percent = (overall_score / 5) * 100
    else:
        overall_score_percent = 0

    # Section scores
    section_scores = {}
    for section, cols in SECTIONS.items():
        matched_cols = [col for col in numeric_df.columns if any(c.strip() in col for c in cols)]
        if matched_cols:
            section_data = numeric_df[matched_cols].values.flatten()
            section_data = section_data[~np.isnan(section_data)]
            section_score = np.mean(section_data) if len(section_data) > 0 else 0
            section_scores[section] = (section_score / 5) * 100

    # Other metrics
    if RECOMMEND_COL in filtered_df.columns:
        recommend_counts = filtered_df[RECOMMEND_COL].value_counts(normalize=True) * 100
        recommend_yes = recommend_counts.get('نعم', 0)
        recommend_no = recommend_counts.get('لا', 0)
        recommend_some = recommend_counts.get('إلى حد ما', 0)
    else:
        recommend_yes = 0
        recommend_no = 0
        recommend_some = 0

    if ALL_SERVICES_COL in filtered_df.columns:
        services_counts = filtered_df[ALL_SERVICES_COL].value_counts(normalize=True) * 100
        services_yes = services_counts.get('نعم', 0)
        services_some = services_counts.get('إلى حد ما', 0)
        services_no = services_counts.get('لا', 0)
    else:
        services_yes = 0
        services_some = 0
        services_no = 0

    if HOURS_SUITABLE_COL in filtered_df.columns:
        hours_counts = filtered_df[HOURS_SUITABLE_COL].value_counts(normalize=True) * 100
        hours_yes = hours_counts.get('نعم', 0)
        hours_no = hours_counts.get('لا', 0)
        hours_some = hours_counts.get('إلى حد ما', 0)
    else:
        hours_yes = 0
        hours_no = 0
        hours_some = 0

    # Open text
    positives = filtered_df[POSITIVES_COL].dropna().unique().tolist() if POSITIVES_COL in filtered_df.columns else []
    suggestions = filtered_df[SUGGESTIONS_COL].dropna().unique().tolist() if SUGGESTIONS_COL in filtered_df.columns else []

    return {
        'centralized_score_percent': centralized_score_percent,
        'overall_score_percent': overall_score_percent,
        'section_scores': section_scores,
        'recommend_yes': recommend_yes,
        'recommend_no': recommend_no,
        'recommend_some': recommend_some,
        'services_yes': services_yes,
        'services_some': services_some,
        'services_no': services_no,
        'hours_yes': hours_yes,
        'hours_no': hours_no,
        'hours_some': hours_some,
        'positives': positives,
        'suggestions': suggestions
    }

# Streamlit UI with security
st.title("Health Center Survey Analysis")

# Password protection using session state
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False

if not st.session_state.authenticated:
    st.subheader("Login")
    password = st.text_input("Enter Password", type="password")
    if st.button("Login"):
        if password == SECURE_PASSWORD:
            st.session_state.authenticated = True
            st.success("Login successful!")
        else:
            st.error("Incorrect password")
    st.stop()

# Main application
st.write("Upload a CSV or PDF file to analyze the health center ratings.")
st.warning("Warning: Ensure the file does not contain sensitive personal information (e.g., names or ID numbers) to protect respondent privacy.")

# File uploader with support for CSV and PDF
uploaded_file = st.file_uploader("Choose a CSV or PDF file", type=["csv", "pdf"])

if uploaded_file is not None:
    # Check file extension
    file_extension = uploaded_file.name.split('.')[-1].lower()
    if file_extension not in ["csv", "pdf"]:
        st.error("Error: Only CSV or PDF files are supported. Please upload a file with a .csv or .pdf extension.")
    else:
        with st.spinner("Processing file..."):
            if file_extension == "csv":
                # Read CSV directly
                df = pd.read_csv(uploaded_file, encoding='utf-8')
                st.success("CSV file loaded successfully.")
            else:
                # Convert PDF to DataFrame using pdfplumber
                try:
                    with pdfplumber.open(uploaded_file) as pdf:
                        # Extract all tables from the first page (adjust pages as needed)
                        tables = []
                        for page in pdf.pages:
                            tables.extend(page.extract_tables())
                        if tables:
                            # Convert the first table to DataFrame (assuming one main table)
                            df = pd.DataFrame(tables[0], columns=[f"Column_{i}" for i in range(len(tables[0][0]))] if tables[0] else [])
                            # Clean up NaN or None values
                            df = df.replace({pd.NA: None, np.nan: None})
                            st.success("PDF file converted and loaded successfully.")
                        else:
                            st.error("Error: No tables found in the PDF. Please ensure the PDF contains structured tables.")
                            st.stop()
                except Exception as e:
                    st.error(f"Error converting PDF: {e}. Please ensure the PDF is readable.")
                    st.stop()

        # Analyze the data
        results = analyze_data(df)

        # Display results
        if results is not None:
            st.header("Analysis Results")

            # Centralized and Overall Scores
            st.subheader("General Ratings")
            st.write(f"- **Centralized Score**: {results['centralized_score_percent']:.0f}%")
            st.write(f"- **Overall Experience Score**: {results['overall_score_percent']:.0f}%")

            # Section Scores
            st.subheader("Ratings by Section")
            st.table({
                "Section": list(results['section_scores'].keys()),
                "Rating (%)": [f"{score:.0f}" for score in results['section_scores'].values()]
            })

            # Other Metrics
            st.subheader("Other Metrics")
            st.write(f"- **Recommendation Rate**: {results['recommend_yes']:.0f}% 'Yes', {results['recommend_some']:.0f}% 'To Some Extent', {results['recommend_no']:.0f}% 'No'")
            st.write(f"- **All Services Availability**: {results['services_yes']:.0f}% 'Yes', {results['services_some']:.0f}% 'To Some Extent', {results['services_no']:.0f}% 'No'")
            st.write(f"- **Operating Hours Suitability**: {results['hours_yes']:.0f}% 'Yes', {results['hours_some']:.0f}% 'To Some Extent', {results['hours_no']:.0f}% 'No'")

            # Open Text Responses
            st.subheader("Open Text Responses")
            st.write("**Notable Positives**:")
            for p in results['positives']:
                st.write(f"- {p}")
            st.write("**Improvement Suggestions**:")
            for s in results['suggestions']:
                st.write(f"- {s}")
        else:
            st.error("No valid data found after processing.")