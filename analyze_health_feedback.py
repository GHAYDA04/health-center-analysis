# -*- coding: utf-8 -*-
"""analyze_health_feedback.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i07JOrkIjtkOnuk-KupWdrP-kRVFF_8z
"""

import streamlit as st
import pandas as pd
import numpy as np
import os

# Define a secure password (replace with a strong password in production)
SECURE_PASSWORD = "HealthCenter2025"  # Replace with a strong password in production

# Mapping for ratings
RATING_MAP = {
    'ممتاز': 5,
    'جيد جدا': 4,
    'جيد': 3,
    'مقبول': 2,
    'ضعيف': 1
}

# Yes/No mapping for percentages
YES_MAP = {
    'نعم': 'yes',
    'إلى حد ما': 'to_some_extent',
    'لا': 'no'
}

# Define sections with their column names (exact or partial for matching)
SECTIONS = {
    'General Medical': [
        'مدى سهولة الوصول والحجز لدى الأطباء',
        'وضوح التشخيص والشرح للمريض',
        'مستوى الاهتمام والمتابعة'
    ],
    'Dental': [
        'سهولة الحجز لمواعيد الأسنان',
        'جودة الخدمة المقدمة',
        'نظافة وتجهيزات عيادة الأسنان'
    ],
    'Pediatrics': [
        'تعامل الكادر الطبي مع الأمهات والأطفال',
        'توفّر الفحوصات اللازمة للأطفال',
        'توفير إرشادات صحية للأم والطفل'
    ],
    'Pharmacy': [
        'سرعة صرف الأدوية',
        'توافر الأدوية المطلوبة',
        'وضوح التعليمات عند صرف الدواء'
    ],
    'Family Clinic': [
        'جودة الخدمات المقدمة في عيادة الأسرة',
        'الاهتمام بتقديم الاستشارات الصحية'
    ],
    'Lab': [
        'سهولة إجراء الفحوصات المخبرية',
        'سرعة استلام النتائج',
        'دقة النتائج المخبرية'
    ],
    'Emergency': [
        'سرعة الاستجابة في قسم الطوارئ',
        'كفاءة الكادر الطبي في التعامل مع الحالات الطارئة',
        'توفر التجهيزات والمعدات اللازمة للحالات الطارئة'
    ],
    'Registration': [
        'سهولة إجراءات التسجيل',
        'سرعة إنجاز المعاملات'
    ],
    'Waiting Area': [
        'توفر أماكن جلوس كافية',
        'نظافة قاعة الانتظار',
        'مدة الانتظار قبل الدخول إلى العيادة'
    ],
    'Cleanliness': [
        'نظافة المركز بشكل عام',
        'توفر دورات مياه نظيفة وصالحة للاستخدام'
    ]
}

# Other key columns
OVERALL_EXPERIENCE_COL = 'بشكل عام، كيف تقيم تجربتك في المركز الصحي؟'
RECOMMEND_COL = 'هل توصي الآخرين بمراجعة هذا المركز الصحي؟'
ALL_SERVICES_COL = 'هل تعتقد أن المركز يوفر جميع الخدمات الصحية التي تحتاجها'
HOURS_SUITABLE_COL = 'هل ساعات عمل المركز مناسبة لك'
POSITIVES_COL = 'ما أبرز الإيجابيات التي وجدتها في المركز الصحي؟'
SUGGESTIONS_COL = 'ما هي اقتراحاتك لتطوير وتحسين خدمات المركز الصحي؟'

def analyze_csv(file_path):
    try:
        # Read CSV
        df = pd.read_csv(file_path, encoding='utf-8')
    except FileNotFoundError:
        st.error(f"Error: The file '{file_path}' does not exist. Please upload a valid CSV file.")
        return None
    except Exception as e:
        st.error(f"Error while reading the file: {e}")
        return None

    # Strip any leading/trailing spaces in column names
    df.columns = df.columns.str.strip()

    # Identify all rating columns (those with values in RATING_MAP)
    rating_cols = [col for col in df.columns if df[col].dropna().isin(RATING_MAP.keys()).any()]

    # Filter out responses where all ratings are the same (e.g., all 'ممتاز', 'ضعيف', etc.)
    filtered_df = df.copy()
    if rating_cols:
        # Convert ratings to numeric for filtering
        temp_df = df[rating_cols].applymap(lambda x: RATING_MAP.get(x, np.nan))
        # Check if all ratings in a row are the same by computing the standard deviation
        row_std = temp_df.std(axis=1, skipna=True)
        # Keep rows where standard deviation is not 0 (i.e., ratings are not all identical)
        filtered_df = df[row_std != 0].reset_index(drop=True)

    # If no rows remain after filtering, display a warning
    if filtered_df.empty:
        st.warning("No responses remain after filtering out uniform ratings (e.g., all 'ممتاز' or 'ضعيف').")
        return None

    # Map ratings to numbers for the filtered DataFrame
    numeric_df = filtered_df[rating_cols].applymap(lambda x: RATING_MAP.get(x, np.nan))

    # Centralized Evaluation Score: average of all ratings across all responses
    all_ratings = numeric_df.values.flatten()
    all_ratings = all_ratings[~np.isnan(all_ratings)]
    centralized_score = np.mean(all_ratings) if len(all_ratings) > 0 else 0

    # Overall Experience Score
    if OVERALL_EXPERIENCE_COL in numeric_df.columns:
        overall_scores = numeric_df[OVERALL_EXPERIENCE_COL].dropna()
        overall_score = np.mean(overall_scores) if not overall_scores.empty else 0
    else:
        overall_score = 0

    # Section scores
    section_scores = {}
    for section, cols in SECTIONS.items():
        matched_cols = [col for col in numeric_df.columns if any(c.strip() in col for c in cols)]
        if matched_cols:
            section_data = numeric_df[matched_cols].values.flatten()
            section_data = section_data[~np.isnan(section_data)]
            section_scores[section] = np.mean(section_data) if len(section_data) > 0 else 0

    # Other metrics
    if RECOMMEND_COL in filtered_df.columns:
        recommend_counts = filtered_df[RECOMMEND_COL].value_counts(normalize=True) * 100
        recommend_yes = recommend_counts.get('نعم', 0)
        recommend_no = recommend_counts.get('لا', 0)
        recommend_some = recommend_counts.get('إلى حد ما', 0)
    else:
        recommend_yes = 0
        recommend_no = 0
        recommend_some = 0

    if ALL_SERVICES_COL in filtered_df.columns:
        services_counts = filtered_df[ALL_SERVICES_COL].value_counts(normalize=True) * 100
        services_yes = services_counts.get('نعم', 0)
        services_some = services_counts.get('إلى حد ما', 0)
        services_no = services_counts.get('لا', 0)
    else:
        services_yes = 0
        services_some = 0
        services_no = 0

    if HOURS_SUITABLE_COL in filtered_df.columns:
        hours_counts = filtered_df[HOURS_SUITABLE_COL].value_counts(normalize=True) * 100
        hours_yes = hours_counts.get('نعم', 0)
        hours_no = hours_counts.get('لا', 0)
        hours_some = hours_counts.get('إلى حد ما', 0)
    else:
        hours_yes = 0
        hours_no = 0
        hours_some = 0

    # Open text
    positives = filtered_df[POSITIVES_COL].dropna().unique().tolist() if POSITIVES_COL in filtered_df.columns else []
    suggestions = filtered_df[SUGGESTIONS_COL].dropna().unique().tolist() if SUGGESTIONS_COL in filtered_df.columns else []

    return {
        'centralized_score': centralized_score,
        'overall_score': overall_score,
        'section_scores': section_scores,
        'recommend_yes': recommend_yes,
        'recommend_no': recommend_no,
        'recommend_some': recommend_some,
        'services_yes': services_yes,
        'services_some': services_some,
        'services_no': services_no,
        'hours_yes': hours_yes,
        'hours_no': hours_no,
        'hours_some': hours_some,
        'positives': positives,
        'suggestions': suggestions
    }

# Streamlit UI with security
st.title("Health Center Survey Analysis")

# Password protection using session state
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False

if not st.session_state.authenticated:
    st.subheader("Login")
    password = st.text_input("Enter Password", type="password")
    if st.button("Login"):
        if password == SECURE_PASSWORD:
            st.session_state.authenticated = True
            st.success("Login successful!")
        else:
            st.error("Incorrect password")
    st.stop()

# Main application
st.write("Upload a CSV file to analyze the health center ratings.")
st.warning("Warning: Ensure the CSV file does not contain sensitive personal information (e.g., names or ID numbers) to protect respondent privacy.")

# File uploader
uploaded_file = st.file_uploader("Choose a CSV file", type="csv")

if uploaded_file is not None:
    # Save the uploaded file temporarily
    temp_file_path = "temp_feedback.csv"
    with open(temp_file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())

    # Analyze the file
    results = analyze_csv(temp_file_path)

    # Immediately delete the temporary file to ensure data privacy
    if os.path.exists(temp_file_path):
        os.remove(temp_file_path)

    # Display results
    if results is not None:
        st.header("Analysis Results")

        # Centralized and Overall Scores
        st.subheader("General Ratings")
        st.write(f"- **Centralized Score** (average of all ratings across responses): {results['centralized_score']:.2f} out of 5")
        st.write(f"- **Overall Experience Score** (average of overall experience field only): {results['overall_score']:.2f} out of 5")

        # Section Scores
        st.subheader("Ratings by Section")
        st.table({
            "Section": list(results['section_scores'].keys()),
            "Rating (out of 5)": [f"{score:.2f}" for score in results['section_scores'].values()]
        })

        # Other Metrics
        st.subheader("Other Metrics")
        st.write(f"- **Recommendation Rate**: {results['recommend_yes']:.0f}% 'Yes', {results['recommend_some']:.0f}% 'To Some Extent', {results['recommend_no']:.0f}% 'No'")
        st.write(f"- **All Services Availability**: {results['services_yes']:.0f}% 'Yes', {results['services_some']:.0f}% 'To Some Extent', {results['services_no']:.0f}% 'No'")
        st.write(f"- **Operating Hours Suitability**: {results['hours_yes']:.0f}% 'Yes', {results['hours_some']:.0f}% 'To Some Extent', {results['hours_no']:.0f}% 'No'")

        # Open Text Responses
        st.subheader("Open Text Responses")
        st.write("**Notable Positives**:")
        for p in results['positives']:
            st.write(f"- {p}")
        st.write("**Improvement Suggestions**:")
        for s in results['suggestions']:
            st.write(f"- {s}")

